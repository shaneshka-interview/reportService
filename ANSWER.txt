Чек-лист:
1) лишние классы + 
2) лишние пакеты + 
3) Выделение DAL + 
4) Выделение форматтера отчетов +
5) Отчеты формируются в неконкуррентый файл  + 
6) Дедлок на потоках при обращении к веб-службе + 
7) Соединение не возвращается в пул при обращении к веб службе + 
8) Убрать весь код из контроллера - 
9) Добавить юнит тестов + 
10) Форматтер отчетов не должен постоянно выделять память (использовать StringBuilder) + 
11) Выкинуть DLL (там внутри Exception швыряется) + 
12) Ну и убрать логический баг что не все сотрудники попадают в отчет + 

доп. плюсы
- Отчеты можно формировать в памяти + 
- Использование IoC +


Замечания:
	+ Разделил проект на несколько сборок.
	+ Добавил логирование 
	+/- Конфиги хоть и вынес в отдельное место, но не в отдельный файл, а в класс.
	+ Прикольная фишка с пометкой работников с ошибками взаимодействия с внешними системами.

	(!) HttpClient'ы являются полями *Api классов, нет управления их жизненным циклом.
	Однако в контроллере есть создание большого количества тасков, которые исполняют метод ReportController.FillSalaryAsync.
	А этот метод в свою очередь асинхронно использует одни и те же экземпляры *Api, а значит и HttpClient'ы. Не уверен, что 
	такое использование HttpClient вообще приведет к чему-то хорошему.

	- Не вынес код из контроллера в слой BL.	

ReportBuilder:
	1) Класс "одноразовый". Если вызвать Create несколько раз, будем получать все предыдущие отчеты.
	2) AddLine не нужен, у StringBuilder есть AppendLine.
	3) +/- Ходим в БД 2 раза. Некритично, но можно обойтись джойном и преобразованием коллекции на клиенте.

EmployeeSalaryApi:
	1) Salary API на вход получает JSON, это было утеряно.

Storage
	1) Один класс для доступа к разным сущностям, можно было бы разделить на 2
	2) Нет управления ресурсами. И Connection, и Command, и Reader реализуют IDisposable. Но в коде, к сожалению, ни одного using.
	3) Почему Task<IEnumerable<Department>> GetDepartmentsAsync(), но IAsyncEnumerable<Employee> GetEmployeesAsync() ?
